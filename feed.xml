<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://inbird81.github.io/</id><title>남조의 삽질기록장</title><subtitle>Unity, Game, C#, AI, artificial intelligence, jekyll</subtitle> <updated>2024-11-30T04:09:04+09:00</updated> <author> <name>남조</name> <uri>https://inbird81.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://inbird81.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://inbird81.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2024 남조 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Application.isPlaying과 Application.isEditor의 차이</title><link href="https://inbird81.github.io/posts/application_isplaying_iseditor/" rel="alternate" type="text/html" title="Application.isPlaying과 Application.isEditor의 차이" /><published>2024-11-22T00:00:00+09:00</published> <updated>2024-11-22T00:00:00+09:00</updated> <id>https://inbird81.github.io/posts/application_isplaying_iseditor/</id> <content src="https://inbird81.github.io/posts/application_isplaying_iseditor/" /> <author> <name>남조</name> </author> <category term="Unity" /> <summary> Application.isPlaying은 빌드된 게임 혹은 에디터의 플레이 모드(에디터에서 실행시키는 것)일 때 true를 반환한다. Application.isEditor는 에디터에서 실행되는지의 여부를 반환한다. Application.isPlaying Application.isEditor 그리고 Application.isEditor는 #if UNITY_EDITOR와 기능적으로 동일하며, 코드가 빌드에 포함되는지의 차이만 있다. Difference between #if UNITY_EDITOR and Application.isEditor? 즉 에디터에서 Play 버튼을 눌러서 에디터 내의 플레이 모드로 실행했을 경우, Application.isPlaying과 Application.... </summary> </entry> <entry><title>Odin Inspector의 PropertyOrder 관련 짧은 팁</title><link href="https://inbird81.github.io/posts/odin-inspector-propertyorder/" rel="alternate" type="text/html" title="Odin Inspector의 PropertyOrder 관련 짧은 팁" /><published>2024-11-18T00:00:00+09:00</published> <updated>2024-11-18T00:00:00+09:00</updated> <id>https://inbird81.github.io/posts/odin-inspector-propertyorder/</id> <content src="https://inbird81.github.io/posts/odin-inspector-propertyorder/" /> <author> <name>남조</name> </author> <category term="Unity" /> <summary> Odin Inspector의 PropertyOrder를 사용하면 인스펙터에서 프로퍼티가 출력되는 순서를 지정할 수 있다. 유니티에서는 상속된 클래스의 프로퍼티가 인스펙터에서 보이는 순서를 지정할 수 없어서 불편할 때가 많은데 PropertyOrder가 이 문제를 해결해준다. 이때, PropertyOrder가 설정되지 않은 일반 프로퍼티의 Order는 0으로 취급되는 것으로 보인다. public class GameBaseSO : SavableSO { [PropertyOrder(1)] // PropertyOrder 1 public string Name; [TextArea(5, 20)] [PropertyOrder(998)] public string HelpText; } public cla... </summary> </entry> <entry><title>ScriptableObject를 참조하는 객체의 JSON Serialize</title><link href="https://inbird81.github.io/posts/json_save_scriptableobject/" rel="alternate" type="text/html" title="ScriptableObject를 참조하는 객체의 JSON Serialize" /><published>2024-11-16T00:00:00+09:00</published> <updated>2024-11-18T04:41:51+09:00</updated> <id>https://inbird81.github.io/posts/json_save_scriptableobject/</id> <content src="https://inbird81.github.io/posts/json_save_scriptableobject/" /> <author> <name>남조</name> </author> <category term="Unity" /> <summary> Unity의 ScriptableObject는 특정한 아이템 유형 등을 정의할 때 Enum처럼 사용할 수 있다. 이는 유니티에서 공식적으로 권장하는 사용 방식이다. 위의 인벤토리 예시는 유니티에서 제공하는 협업과 코딩 측면에서 유용한 스크립터블 오브젝트 활용법 6가지라는 강좌에 있는 내용이다. 여기까지는 괜찮지만, 문제는 이 인벤토리 정보를 저장하려고 할 때 발생한다. 유니티에서 가장 일반적으로 사용되든 게임 데이터 저장방법은 Json이다. 위의 예시와 유사한 코드를 만들어서 세이브를 구현해보자. using UnityEngine; public class ItemTemplete : ScriptableObject { } public class InventoryTest : MonoBehavio... </summary> </entry> <entry><title>UI Text, TextMeshPro, TextCore?</title><link href="https://inbird81.github.io/posts/textmeshpro_textcore/" rel="alternate" type="text/html" title="UI Text, TextMeshPro, TextCore?" /><published>2024-11-16T00:00:00+09:00</published> <updated>2024-11-16T00:00:00+09:00</updated> <id>https://inbird81.github.io/posts/textmeshpro_textcore/</id> <content src="https://inbird81.github.io/posts/textmeshpro_textcore/" /> <author> <name>남조</name> </author> <category term="Unity" /> <summary> 최근에 유니티 6을 사용해봤는데, 생성할 수 있는 객체 중에 TextMeshpro와 TextCore라는 게 나눠져 있었다. TextMeshpro는 현 시점(유니티 6 프리뷰)에서는 별도의 패키지지만 사용할 때 자동으로 다운받는 창이 뜨는 구조였고, 기존 UI Text는 역시 남아 있지만 legacy로 분류되어 있다. 이게 뭔지 몰라서 찾아본 바로는, 공식적인 답변은 아니지만 TextCore가 TextMeshpro를 기본 텍스트 기능으로 통합한 것이라고 한다. 그럼 이게 왜 TextMeshpro와 따로 존재하는가? 아직 통합 작업이 끝나지 않아서라는 게 내가 찾은 답변이었다. 현 시점에는 통합이 완전하지 않아서, 유니티의 UI Element에서는 TextCore를 쓰고 UGUI에서는 TextMes... </summary> </entry> <entry><title>Spine에서 실시간으로 material 변경하기</title><link href="https://inbird81.github.io/posts/spine2d_override_material/" rel="alternate" type="text/html" title="Spine에서 실시간으로 material 변경하기" /><published>2024-10-03T00:00:00+09:00</published> <updated>2024-10-06T13:00:59+09:00</updated> <id>https://inbird81.github.io/posts/spine2d_override_material/</id> <content src="https://inbird81.github.io/posts/spine2d_override_material/" /> <author> <name>남조</name> </author> <category term="Unity" /> <summary> 유니티 게임개발 시 많이 사용되는 Spine을 쓰던 도중, 스파인 애니메이션 중에 실시간으로 메테리얼을 교체해야 하는 이슈가 있었다. 맨 처음에는 평범하게 유니티 Mesh Renderer에서 직접 material을 변경해봤다. obj.GetComponent&amp;lt;MeshRenderer&amp;gt;().material = newMaterial; // 단일 메테리얼일 때 obj.GetComponent&amp;lt;Renderer&amp;gt;().materials = new Material[2] {newMaterial, newMaterial}; // 여러 개의 메테리얼을 교체할 때 유니티(Unity) Materials 일부 변경하기 하지만 실제 게임에서는 효과가 없었다. 아마도 Spine이 애니메이션을 제어하면... </summary> </entry> </feed>
